% 有天气有路径，不能挖矿也不能停留，我们叫他如如

% 定义邻接矩阵p，初始资金c，总天数n，起点s，终点t
p = [
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0;
0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0;
0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0;
0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0;
0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0;
0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0;
0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0;
0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 1 0 0 0 0 1 0 0 0 0 0;
0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0;
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 0 0 1;
0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0;
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0;
0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0;
1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0;
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1;
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0;
];
c = 10000;
s = 1;
t = 20; % 假设终点是邻接矩阵的最后一个点

% 定义每一天的天气情况w和每种天气对应的花费e
weather = [2 2 1 3 1 2 3 1 2 2 3 2 1 2 2 2 3 3 2 2 1 1 2 1 3 2 1 1 2 2]; % 长度为30的向量
weather_price = [-100 -200 -300]; % 长度为3的向量

% 初始化一些参数
m = size(p,1); % 点的个数
flag = false; % 是否找到路径的标志

% 尝试不同的n值
for n = 1:30
    f = zeros(m,n); % f(i,j)表示第j天到达第i个点的最大收益
    pre = zeros(m,n); % pre(i,j)表示第j天到达第i个点的前一个点
    path = zeros(1,n); % path(i)表示第i天所在的点位

    % 更新f和pre矩阵
    f(s,1) = c; % 第一天只有起点有收益
    for j = 2:n % 第二天到最后一天
        for i = 1:m % 每一个点
            for k = find(p(i,:)) % 和它相邻的点
                if f(k,j-1) > f(i,j) % 如果收益更大
                    f(i,j) = f(k,j-1); % 更新收益
                    pre(i,j) = k; % 更新前驱
                end
            end
        end
    end

    % 如果最后一天到达终点的收益大于零，则找到了可行的路径，退出循环
    if f(t,n) > 0
        flag = true;
        break;
    end
end

% 如果找到了路径，则回溯并打印出来
if flag
    % 目标函数值
    max_profit = f(t,n)

    % 回溯最优路径
    path(n) = t; % 最后一天是终点
    for j = n-1:-1:1 % 倒着回溯
        path(j) = pre(path(j+1),j+1); % 根据前驱找到当前点位
    end

    % 打印每天所在的点位
    disp('每天所在的点位如下：')
    for j = 1:n
        fprintf('第%d天：第%d个点\n',j,path(j))
    end

else
    disp('没有找到可行的路径')
end
